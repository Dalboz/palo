////////////////////////////////////////////////////////////////////////////////
/// @brief palo cache page
///
/// @file
///
/// The contents of this file are subject to the Jedox AG Palo license. You
/// may not use this file except in compliance with the license. You may obtain
/// a copy of the License at
///
/// <a href="http://www.palo.com/license.txt">
///   http://www.palo.com/license.txt
/// </a>
///
/// Software distributed under the license is distributed on an "AS IS" basis,
/// WITHOUT WARRANTY OF ANY KIND, either express or implied.  See the license
/// for the specific language governing rights and limitations under the
/// license.
///
/// Developed by triagens GmbH, Koeln on behalf of Jedox AG. Intellectual
/// property rights has triagens GmbH, Koeln. Exclusive worldwide
/// exploitation right (commercial copyright) has Jedox AG, Freiburg.
///
/// @author Frank Celler, triagens GmbH, Cologne, Germany
/// @author Achim Brandt, triagens GmbH, Cologne, Germany
////////////////////////////////////////////////////////////////////////////////

#ifndef OLAP_CACHE_PAGE_H
#define OLAP_CACHE_PAGE_H 1

#include "palo.h"

#include <set>

namespace palo {
  class CubeIndex;

  ////////////////////////////////////////////////////////////////////////////////
  /// @brief palo cache page
  /// 
  /// A cache page stores/cachss the consolidated cell data into a fixed memory size.
  ////////////////////////////////////////////////////////////////////////////////

  class SERVER_CLASS CachePage {

  public:
    typedef uint8_t * buffer_t;
    typedef uint8_t * element_t;
    typedef uint8_t * key_t;
    typedef uint8_t * value_t;
    typedef uint8_t * counter_t;

  public:
  
    ////////////////////////////////////////////////////////////////////////////////
    /// @brief size of a cache page
    ///
    /// Memory pages will be allocated in multiple of this values.
    ////////////////////////////////////////////////////////////////////////////////

    static const size_t PAGE_SIZE = 1024;

  public:

    ////////////////////////////////////////////////////////////////////////////////
    /// @brief creates an empty cache page 
    ////////////////////////////////////////////////////////////////////////////////

    CachePage (CubeIndex* index,
              size_t keySize,
              size_t valueSize,
              size_t counterSize);

    ////////////////////////////////////////////////////////////////////////////////
    /// @brief delete cube storage
    ////////////////////////////////////////////////////////////////////////////////

    virtual ~CachePage ();
    
  public:

    ////////////////////////////////////////////////////////////////////////////////
    /// @brief adds an entry to cube
    ////////////////////////////////////////////////////////////////////////////////

    element_t addElement (element_t);

    ////////////////////////////////////////////////////////////////////////////////
    /// @brief removes an entry from the cube
    ////////////////////////////////////////////////////////////////////////////////

    element_t removeElement (element_t);

    ////////////////////////////////////////////////////////////////////////////////
    /// @brief returns a pointer to the beginning
    ////////////////////////////////////////////////////////////////////////////////

    buffer_t begin () {
      return buffer;
    }

    ////////////////////////////////////////////////////////////////////////////////
    /// @brief returns a pointer to the end (first non-used entry)
    ////////////////////////////////////////////////////////////////////////////////

    buffer_t end () {
      return buffer + usedElements * rowSize;
    }

    ////////////////////////////////////////////////////////////////////////////////
    /// @brief returns the used size
    ////////////////////////////////////////////////////////////////////////////////

    size_t size () {
      return totalSize;
    }
    
    
    ////////////////////////////////////////////////////////////////////////////////
    /// @brief returns the used row size
    ////////////////////////////////////////////////////////////////////////////////

    size_t getRowSize () {
      return rowSize;
    }
    
    ////////////////////////////////////////////////////////////////////////////////
    /// @brief returns the number of used rows
    ////////////////////////////////////////////////////////////////////////////////

    size_t getNumberElements () {
      return usedElements;
    }    
    
    ////////////////////////////////////////////////////////////////////////////////
    /// @brief returns the cache size of all cache pages
    ////////////////////////////////////////////////////////////////////////////////
    
    virtual size_t getTotalCacheSize () = 0;

    ////////////////////////////////////////////////////////////////////////////////
    /// @brief returns the maximum cache size 
    ////////////////////////////////////////////////////////////////////////////////
    
    virtual size_t getMaximumCacheSize () = 0;

  public:
    void print ();
    
    // delete rows by a list of ids of one dimension
    void deleteRows(size_t num, set<IdentifierType>* ids);

    virtual void shrink ();

  protected:
    virtual void grow ();
  
  private:
    void sort ();

    void saveElement (size_t src);

    void restoreElement (size_t dst);

    void copyElement (size_t dst, size_t src);

    bool isBiggerElement (size_t right);
    
  protected:

    ////////////////////////////////////////////////////////////////////////////////
    /// @brief cube index for resize
    ////////////////////////////////////////////////////////////////////////////////

    CubeIndex * index;

    ////////////////////////////////////////////////////////////////////////////////
    /// @brief sorted flag
    ////////////////////////////////////////////////////////////////////////////////

    bool sorted;

    ////////////////////////////////////////////////////////////////////////////////
    /// @brief size of the key
    ////////////////////////////////////////////////////////////////////////////////

    size_t keySize;

    ////////////////////////////////////////////////////////////////////////////////
    /// @brief size of the value
    ////////////////////////////////////////////////////////////////////////////////

    size_t valueSize;

    ////////////////////////////////////////////////////////////////////////////////
    /// @brief size of the counter value
    ////////////////////////////////////////////////////////////////////////////////

    size_t counterSize;

    ////////////////////////////////////////////////////////////////////////////////
    /// @brief size of an entry
    ///
    /// Aligned element size.
    ////////////////////////////////////////////////////////////////////////////////

    size_t rowSize;

    ////////////////////////////////////////////////////////////////////////////////
    /// @brief total size of the page
    ////////////////////////////////////////////////////////////////////////////////

    size_t totalSize;

    ////////////////////////////////////////////////////////////////////////////////
    /// @brief used number of rows per page 
    ////////////////////////////////////////////////////////////////////////////////

    size_t usedElements;

    ////////////////////////////////////////////////////////////////////////////////
    /// @brief number of rows per page 
    ////////////////////////////////////////////////////////////////////////////////

    size_t numberElements;

    ////////////////////////////////////////////////////////////////////////////////
    /// @brief pointer to the page memory 
    ////////////////////////////////////////////////////////////////////////////////

    buffer_t buffer;

    ////////////////////////////////////////////////////////////////////////////////
    /// @brief temporary buffer for one row
    ////////////////////////////////////////////////////////////////////////////////

    element_t tmpBuffer;
    
  };

}

#endif
