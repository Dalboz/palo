////////////////////////////////////////////////////////////////////////////////
/// @brief abstract class for palo dimension
///
/// @file
///
/// Copyright (C) 2006-2008 Jedox AG
///
/// This program is free software; you can redistribute it and/or modify it
/// under the terms of the GNU General Public License (Version 2) as published
/// by the Free Software Foundation at http://www.gnu.org/copyleft/gpl.html.
///
/// This program is distributed in the hope that it will be useful, but WITHOUT
/// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
/// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
/// more details.
///
/// You should have received a copy of the GNU General Public License along with
/// this program; if not, write to the Free Software Foundation, Inc., 59 Temple
/// Place, Suite 330, Boston, MA 02111-1307 USA
/// 
/// You may obtain a copy of the License at
///
/// <a href="http://www.jedox.com/license_palo.txt">
///   http://www.jedox.com/license_palo.txt
/// </a>
///
/// If you are developing and distributing open source applications under the
/// GPL License, then you are free to use Palo under the GPL License.  For OEMs,
/// ISVs, and VARs who distribute Palo with their products, and do not license
/// and distribute their source code under the GPL, Jedox provides a flexible
/// OEM Commercial License.
///
/// Developed by triagens GmbH, Koeln on behalf of Jedox AG. Intellectual
/// property rights has triagens GmbH, Koeln. Exclusive worldwide
/// exploitation right (commercial copyright) has Jedox AG, Freiburg.
///
/// @author Frank Celler, triagens GmbH, Cologne, Germany
/// @author Achim Brandt, triagens GmbH, Cologne, Germany
////////////////////////////////////////////////////////////////////////////////

#ifndef OLAP_DIMENSION_H
#define OLAP_DIMENSION_H 1

#include "palo.h"

#include <set>

#include "Exceptions/ParameterException.h"

#include "Olap/Element.h"
#include "Olap/User.h"

namespace palo {
  class FileReader;
  class FileWriter;
  class Database;
  class Cube;

  ////////////////////////////////////////////////////////////////////////////////
  /// @brief abstract super class for OLAP dimension
  ////////////////////////////////////////////////////////////////////////////////

  class SERVER_CLASS Dimension {
    public:

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief list of parents
      ////////////////////////////////////////////////////////////////////////////////

      typedef vector<Element*> ParentsType;
    
    public:  

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief status of the dimension
      /// 
      /// LOADED:   the dimension is loaded and not changed<br>
      /// CHANGED:  the dimension is new or changed
      ////////////////////////////////////////////////////////////////////////////////
  
      enum DimensionStatus {
        LOADED,
        CHANGED
      };

    public:
      static Dimension* loadDimensionFromType (FileReader*,
                                               Database*,
                                               IdentifierType, 
                                               const string& name,
                                               uint32_t type);
    
    public:

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief creates new dimension with given identifier
      ////////////////////////////////////////////////////////////////////////////////

      Dimension (IdentifierType identifier, const string& name, Database* database) 
        : token(0),
          identifier(identifier),
          database(database), 
          status(CHANGED),
          name(name),
          deletable(true),
          renamable(true),
          changable(true) {
      }
    
      ////////////////////////////////////////////////////////////////////////////////
      /// @brief deletes dimension
                ////////////////////////////////////////////////////////////////////////////////

      virtual ~Dimension () {
      }

    public:
    
      ////////////////////////////////////////////////////////////////////////////////
      /// @{
      /// @name notification callbacks
      ////////////////////////////////////////////////////////////////////////////////

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief called before a dimension has been added to a database
      ////////////////////////////////////////////////////////////////////////////////
      
      virtual void beforeAddDimension () {
      }

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief called after a dimension has been added to a database
      ////////////////////////////////////////////////////////////////////////////////
      
      virtual void notifyAddDimension () {
      }

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief called before a dimension has been removed from a database
      ////////////////////////////////////////////////////////////////////////////////
      
      virtual void beforeRemoveDimension () {
      }

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief called after a dimension has been removed from a database
      ////////////////////////////////////////////////////////////////////////////////
      
      virtual void notifyRemoveDimension () {
      }

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief called before a dimension has been renamed
      ////////////////////////////////////////////////////////////////////////////////
      
      virtual void beforeRenameDimension () {
      }

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief called after a dimension has been renamed
      ////////////////////////////////////////////////////////////////////////////////
      
      virtual void notifyRenameDimension (const string& oldName) {
      }

      ////////////////////////////////////////////////////////////////////////////////
      /// @}
      ////////////////////////////////////////////////////////////////////////////////

    public:  

    ////////////////////////////////////////////////////////////////////////////////
    /// @{
    /// @name functions to save and load the dimension
    ////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////
    /// @brief reads data from file
    ////////////////////////////////////////////////////////////////////////////////

      virtual void loadDimension (FileReader* file) = 0;
    
      ////////////////////////////////////////////////////////////////////////////////
      /// @brief saves dimension name and type to file  
      ////////////////////////////////////////////////////////////////////////////////

      virtual void saveDimensionType (FileWriter* file) = 0;
      
      ////////////////////////////////////////////////////////////////////////////////
      /// @brief saves data to file  
      ////////////////////////////////////////////////////////////////////////////////

      virtual void saveDimension (FileWriter* file) = 0;
      
      ////////////////////////////////////////////////////////////////////////////////
      /// @}
      ////////////////////////////////////////////////////////////////////////////////

    public:  

    ////////////////////////////////////////////////////////////////////////////////
    /// @{
    /// @name getter and setter
    ////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////
    /// @brief gets identifier of dimension
    ////////////////////////////////////////////////////////////////////////////////

      IdentifierType getIdentifier () {
        return identifier;
      }
    
      ////////////////////////////////////////////////////////////////////////////////
      /// @brief sets or rename dimension
      ///
      // This method is used internally, so no access rights are checked
      ////////////////////////////////////////////////////////////////////////////////

      virtual void setName (const string& name) {
        this->name = name;
        updateToken();
      }

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief gets dimension name
      ////////////////////////////////////////////////////////////////////////////////

      const string& getName () {
        return name;
      }

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief sets the status of the dimension
      ////////////////////////////////////////////////////////////////////////////////

      void setStatus (DimensionStatus status);
    
      ////////////////////////////////////////////////////////////////////////////////
      /// @brief returns the status of the dimension
      ////////////////////////////////////////////////////////////////////////////////

      DimensionStatus getStatus() {
        return status;
      }
    
      ////////////////////////////////////////////////////////////////////////////////
      /// @brief sets deletable attribute
      ////////////////////////////////////////////////////////////////////////////////

      void setDeletable (bool deletable) {
        this->deletable = deletable;
      }

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief gets deletable attribute
      ////////////////////////////////////////////////////////////////////////////////

      bool isDeletable () const {
        return deletable;
      }

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief sets renamable attribute
      ////////////////////////////////////////////////////////////////////////////////

      void setRenamable (bool renamable) {
        this->renamable = renamable;
      }

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief gets renamable attribute
      ////////////////////////////////////////////////////////////////////////////////

      bool isRenamable () const {
        return renamable;
      }

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief sets changable attribute
      ////////////////////////////////////////////////////////////////////////////////

      void setChangable (bool changable) {
        this->changable = changable;
      }

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief gets changable attribute
      ////////////////////////////////////////////////////////////////////////////////

      bool isChangable () const {
        return changable;
      }

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief gets the token
      ////////////////////////////////////////////////////////////////////////////////

      uint32_t getToken () const {
        return token;
      }

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief gets thedatabase
      ////////////////////////////////////////////////////////////////////////////////

      Database* getDatabase () const {
        return database;
      }

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief returns dimension type
      ////////////////////////////////////////////////////////////////////////////////

      virtual ItemType getType () = 0;
  
      ////////////////////////////////////////////////////////////////////////////////
      /// @brief gets highest consolidation level
      ////////////////////////////////////////////////////////////////////////////////

      virtual LevelType getLevel () = 0;

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief gets highest indentation
      ////////////////////////////////////////////////////////////////////////////////

      virtual IndentType getIndent () = 0;

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief gets highest consolidation depth
      ////////////////////////////////////////////////////////////////////////////////

      virtual DepthType getDepth () = 0;

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief calculate memory usage of the hash maps 
      ////////////////////////////////////////////////////////////////////////////////

      virtual size_t getMemoryUsageIndex () = 0;

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief calculate memory usage of the elements vector 
      ////////////////////////////////////////////////////////////////////////////////

      virtual size_t getMemoryUsageStorage () = 0;

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief gets list of elements (sorted by position)
      ////////////////////////////////////////////////////////////////////////////////

      virtual vector<Element*> getElements (User* user) = 0;

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief gets maximal used identifier
      ////////////////////////////////////////////////////////////////////////////////

      virtual IdentifierType getMaximalIdentifier () = 0;

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief returns the list of cubes who are using the dimension
      ////////////////////////////////////////////////////////////////////////////////

      vector<Cube*> getCubes (User* user);

      ////////////////////////////////////////////////////////////////////////////////
      /// @}
      ////////////////////////////////////////////////////////////////////////////////

    public:

    ////////////////////////////////////////////////////////////////////////////////
    /// @{
    /// @name functions to update internal structures
    ////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////
    /// @brief increments the token
    ////////////////////////////////////////////////////////////////////////////////

      void updateToken ();

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief updates level, indent, and depth information
      ////////////////////////////////////////////////////////////////////////////////

      virtual void updateLevelIndentDepth () = 0;

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief updates base element list of each element
      ////////////////////////////////////////////////////////////////////////////////

      virtual void updateElementBaseElements () = 0;

      ////////////////////////////////////////////////////////////////////////////////
      /// @}
      ////////////////////////////////////////////////////////////////////////////////

    public:

    ////////////////////////////////////////////////////////////////////////////////
    /// @{
    /// @name element functions
    ////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////
    /// @brief deletes all elements
    ////////////////////////////////////////////////////////////////////////////////

      virtual void clearElements (User* user) = 0;

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief gets number of elements
      ////////////////////////////////////////////////////////////////////////////////

      virtual size_t sizeElements () = 0;

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief adds (new) element (returns identifier of new element)
      ////////////////////////////////////////////////////////////////////////////////

      virtual Element* addElement (const string& name,
                                   Element::ElementType elementType, 
                                   User* user,
                                   bool useJournal = true) = 0;

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief deletes element
      ////////////////////////////////////////////////////////////////////////////////

      virtual void deleteElement (Element * element,
                                  User* user,
                                  bool useJournal = true) = 0;

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief delete elements
      ////////////////////////////////////////////////////////////////////////////////

      virtual void deleteElements (std::vector<Element *> elementList,
                                   User* user,
                                   bool useJournal = true) = 0;

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief changes name of element
      ////////////////////////////////////////////////////////////////////////////////

      virtual void changeElementName (Element * element,
                                      const string& name,
                                      User* user) = 0;

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief changes type of element
      ////////////////////////////////////////////////////////////////////////////////

      virtual void changeElementType (Element * element,
                                      Element::ElementType elementType,
                                      User* user,
                                      bool setConsolidated) = 0;

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief moves element (change position of element)
      ////////////////////////////////////////////////////////////////////////////////

      virtual void moveElement (Element * element,
                                PositionType newPosition,
                                User* user) = 0;

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief get parent elements (ordered by position)
      ////////////////////////////////////////////////////////////////////////////////

      virtual const ParentsType* getParents (Element * child) = 0;
    
      ////////////////////////////////////////////////////////////////////////////////
      /// @brief compute all ancestors of an elements
      ////////////////////////////////////////////////////////////////////////////////

      virtual set<Element*> ancestors (Element * child) = 0;
    
      ////////////////////////////////////////////////////////////////////////////////
      /// @brief gets child elements
      ////////////////////////////////////////////////////////////////////////////////

      virtual const ElementsWeightType * getChildren (Element* parent) = 0;

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief gets the base elements
      ////////////////////////////////////////////////////////////////////////////////

      virtual set<Element*> getBaseElements (Element* parent, bool* multiple) = 0;

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief adds childs to (consolidated) element
      ////////////////////////////////////////////////////////////////////////////////

      virtual void addChildren (Element * parent,
                                const ElementsWeightType * children, 
                                User* user) = 0;

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief removes childs from (consolidated) element
      ////////////////////////////////////////////////////////////////////////////////

      virtual void removeChildrenNotIn (User*,
                                        Element * parent,
                                        set<Element*> * keep) = 0;

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief removes childs from (consolidated) element
      ////////////////////////////////////////////////////////////////////////////////

      virtual void removeChildren (User*,
                                   Element * parent) = 0;

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief returns true if element is a string consolidation
      ////////////////////////////////////////////////////////////////////////////////

      virtual bool isStringConsolidation (Element * element) = 0;
    
      ////////////////////////////////////////////////////////////////////////////////
      /// @brief gets element by identifier
      ////////////////////////////////////////////////////////////////////////////////

      virtual Element * lookupElement (IdentifierType elementIdentifier) = 0;

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief gets element by name
      ////////////////////////////////////////////////////////////////////////////////

      virtual Element * lookupElementByName (const string& name) = 0;
    
      ////////////////////////////////////////////////////////////////////////////////
      /// @brief gets element by position
      ////////////////////////////////////////////////////////////////////////////////

      virtual Element * lookupElementByPosition (PositionType position) = 0;

      ////////////////////////////////////////////////////////////////////////////////
      /// @brief gets element by identifier
      ////////////////////////////////////////////////////////////////////////////////

      virtual Element* findElement (IdentifierType elementIdentifier, User* user) = 0;
    
      ////////////////////////////////////////////////////////////////////////////////
      /// @brief gets element by name
      ////////////////////////////////////////////////////////////////////////////////

      virtual Element * findElementByName (const string& name, User* user) = 0;
    
      ////////////////////////////////////////////////////////////////////////////////
      /// @brief gets element by position
      ////////////////////////////////////////////////////////////////////////////////

      virtual Element * findElementByPosition (PositionType position, User* user) = 0;

      ////////////////////////////////////////////////////////////////////////////////
      /// @}
      ////////////////////////////////////////////////////////////////////////////////

    protected:

    ////////////////////////////////////////////////////////////////////////////////
    /// @{
    /// @name user permissions
    ////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////
    /// @brief checks cube access
    ////////////////////////////////////////////////////////////////////////////////

      virtual void checkCubeAccessRight (User* user, RightsType minimumRight) {
        if (user != 0 && user->getRoleCubeRight() < minimumRight) {
          throw ParameterException(ErrorException::ERROR_NOT_AUTHORIZED,
                                   "insufficient access rights for cube",
                                   "user", (int) user->getIdentifier());
        }
      }
    
      ////////////////////////////////////////////////////////////////////////////////
      /// @brief checks element access
      ////////////////////////////////////////////////////////////////////////////////

      virtual void checkElementAccessRight (User* user, RightsType minimumRight) {
        if (user != 0 && user->getRoleElementRight() < minimumRight) {
          throw ParameterException(ErrorException::ERROR_NOT_AUTHORIZED,
                                   "insufficient access rights for dimension element",
                                   "user", (int) user->getIdentifier());
        }
      }  

      ////////////////////////////////////////////////////////////////////////////////
      /// @}
      ////////////////////////////////////////////////////////////////////////////////

    protected:

    ////////////////////////////////////////////////////////////////////////////////
    /// @brief returns true if the dimension is used in a locked cube
    ////////////////////////////////////////////////////////////////////////////////

      bool isLockedByCube ();
    
    
    protected:
      uint32_t token; // token for changes
      IdentifierType identifier; // identifier of the dimension
      Database * database; // pointer to the database
      DimensionStatus status; // status of the dimension
      string name; // name of the dimension
      bool deletable;
      bool renamable;
      bool changable;
  };

}

#endif
